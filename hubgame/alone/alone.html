<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../script.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Carme&display=swap" rel="stylesheet">
</head>
<body class="fade-in">
    <!-- Navbar -->
       <div id="navbar"></div>

    <!-- End Navbar  -->


<div class="container" align = "center">
  

      
    <h1 style="font-weight: bold;font-size: 60px;margin-top: 3%;">Alone</h1>


  <h2 style="color : var(--accent); margin-bottom: 2%;">Game in class</h2>
  
    <hr>

<div class="game-container">
  
<iframe
  src="https://itch.io/embed-upload/15507616?color=333333"
  frameborder="0"
  allowfullscreen
  width="960"
  height="540">
  <a href="https://pxxsx35.itch.io/alone">Play Alone on itch.io</a>
</iframe>
</div>

    <!-- End Game Alone -->
    
    <br>
    <div class="box-btn">
            <a href="https://pxxsx35.itch.io/alone" class="btn" target="_blank">Itch.io</a>
            <!-- <a href="" class="btn">GitHub</a> -->
    </div>
     <h5 align = "right">Dev by: Kanchaphum  Thinthachana , Teerapuwanai Chanachaisombud</h5>
    
    <hr>
    <br>

    <div class="explanntion">
      <h2 >  Alone Game Machanic</h2>
      <br>
      <img src="picture/gameloop.png" alt="" srcset="" class="coding">
    </div>
    <!-- End GameLoop -->
    <hr>
    <br>
    <div class="explanntion">
     <h1 style="font-weight: bold;font-size: 60px;margin-top: 3%;">Features</h1> <br>
     <!-- First -->
     <h2 style="text-align: left;"><strong style="font-weight: bold;"> Class PlayerController</strong> <br>This class handles the player’s movement, jumping, health, animations, sounds, and enemy detection. It serves as the foundation for more advanced features like state machines and environmental interaction</h2>
    <img src="picture/p1.png" alt="" class="coding">
    
    <!-- Move Method -->
       <h2 style="text-align: left;"><strong style="font-weight: bold;"> Function Move</strong> <br>I structured the player movement logic into a separate function for modularity, making it easy to call and maintain. This approach also simplifies debugging, allows smooth integration of animations and input handling, and ensures scalability for future features.</h2>
    <img src="picture/p2.png" alt="" class="coding">

    <!-- 3 thing -->
      <h2 style="text-align: left;">I implemented a set of player control functions to handle different gameplay scenarios.
<br><br>
<strong style="font-weight: bold;">StopAnim() </strong> stops all player animations, plays the death sound, triggers the game over UI, and pauses the game when the player dies.
<br><br>
<strong style="font-weight: bold;">RestartGame()</strong> activates the restart interface, allowing the player to retry.
<br><br>
<strong style="font-weight: bold;">DetectEnemyAndPlayHeartbeat() </strong> continuously checks for nearby enemies and plays a heartbeat audio cue when any are within detection range, enhancing tension and player feedback.
<br><br>
This modular approach keeps the gameplay logic organized, makes it easier to debug, and allows each component to be reused or adjusted independently.</h2>
      <img src="picture/p3.png" alt="" class="coding">

    <!-- both of method -->
      <h2 style="text-align: left;">I implemented collision and trigger detection for player interactions:
<br><br>
<strong style="font-weight: bold;">OnCollisionEnter2D() </strong> resets the player's jump count when touching the ground, enabling double jumps.
<br><br>
<strong style="font-weight: bold;">OnTriggerEnter2D()</strong> handles level progression and quest interactions: entering a "win" trigger loads the victory scene, and collecting a "key" with the correct color completes a quest and updates the key's visual state.
<br><br>

This modular approach keeps the gameplay logic organized, makes it easier to debug, and allows each component to be reused or adjusted independently.</h2>
      <img src="picture/p4.png" alt="" class="coding">

<!-- Function UI & other -->
       <h2 style="text-align: left;">To make player character management clear, maintainable, and scalable, I separated key functionality into small, focused modular functions. This design improves readability, simplifies debugging, and reduces the risk of errors when making changes.
<br><br>
<strong style="font-weight: bold;">UpdateHealthUI() </strong> Updates the health UI in real time using Lerp to create smooth, natural transitions for the health and delayed health bars.
<br><br>
<strong style="font-weight: bold;">StopMovement()</strong> Instantly stops the player’s movement, used when the player dies or is temporarily immobilized.

<br><br>
<strong style="font-weight: bold;">CheckPlayerStatus()</strong> Monitors the player’s state, including death or movement restrictions, and triggers animations and events as needed.
<br><br>
<strong style="font-weight: bold;">HandleDamageFeedback()</strong> Provides immediate audio feedback when the player takes damage, enhancing player awareness of their status.
<br><br>


By structuring functions this way, the player’s Update() method becomes organized and easy to extend for future features, such as power-ups, abilities, or new gameplay mechanics.</h2>
      <img src="picture/p5.png" alt="" class="coding">

   <!-- both of method -->
      <h2 style="text-align: left;">In the PlayerControl class, all core functionality is modularized into dedicated methods for clarity and maintainability. The Update() method then serves as a single, readable flow that calls these methods in a logical order, making the class easier to read, debug, and extend.
</h2>
      <img src="picture/p6.png" alt="" class="coding">


<!-- Function Enemy AI  -->
       <h2 style="text-align: left;"><strong style="font-weight: bold;">Enemy AI – Movement & Attack System </strong>  <br> This enemy class is structured to provide clear behavior and maintainable code by separating responsibilities into key functions:
<br><br>
<strong style="font-weight: bold;">Patrol() </strong> <br> The enemy moves back and forth between the start position and a defined patrol distance. <br>

When reaching the boundary, Flip() is called to reverse direction. <br>

Movement is handled via Rigidbody2D, and walking animation (isWalking) is updated in the Animator. <br>
<br>
<strong style="font-weight: bold;">FollowPlayer()</strong> <br>The enemy moves toward the player’s position on the X-axis. <br>

If facing the wrong direction, Flip() adjusts the sprite orientation. <br>

Walking animation is kept active during movement. <br>

<br>
<strong style="font-weight: bold;">StopAndAttackPlayer() & AttackPlayer()</strong> <br> When within attack range, the enemy stops moving (rb.velocity = 0) and triggers the attack animation (atk) with a sound effect.
<br>
AttackPlayer() coroutine adds a delay before applying damage. <br>

If the player is in range, health is reduced and the corresponding player animation (hurt or dead) is triggered. <br> <br>
<strong style="font-weight: bold;">Flip()</strong> <br>Toggles the movingRight boolean. <br>

Adjusts the sprite’s localScale to face the correct direction.
<br>


By structuring functions this way, the player’s Update() method becomes organized and easy to extend for future features, such as power-ups, abilities, or new gameplay mechanics.</h2>
      <img src="picture/p7.png" alt="" class="coding">


<!-- Sum Enemy -->
      <h2 style="text-align: left;">Enemy AI  Design & Rationale <br>

The enemy is designed for clarity, realism, and easy maintenance <br><br>

Stable Initialization  References to Player, Animator, and Rigidbody2D are set in Start() with null checks to prevent errors. <br><br>

Distance-Based Behavior  Switches dynamically between patrolling, chasing, and attacking based on player distance. <br><br>

Attack Timing  Uses attackDelay to add realistic intervals between attacks. <br><br>

Clean & Flexible Code  Clear function separation allows easy adjustments or new behaviors.</h2>
      <img src="picture/p8.png" alt="" class="coding">


<!-- Enemy Spawn -->
      <h2 style="text-align: left;">Enemy Spawner  Design & Rationale <br>

This script handles dynamic enemy spawning with control over timing, quantity, and locationbr><br>

Trigger-Based Activation – Spawning starts only when the player enters the trigger, ensuring events are context-sensitive.<br><br>

Controlled Spawn Rate – spawnDelay prevents all enemies from appearing at once, improving gameplay pacing. <br><br>

Randomized Positioning – Slight horizontal variation makes encounters less predictable and more engaging.<br><br>

Single Execution Safety – hasTriggered ensures the spawner runs only once per activation to avoid unintended duplication. <br><br>
Designed for flexibility, performance, and engaging gameplay, with easily adjustable parameters for enemy quantity, spawn delay, and positions.
</h2>
      <img src="picture/p9.png" alt="" class="coding">


      <!-- Quest System-->
      <h2 style="text-align: left;">Quest System Overview <br>

This Quest class manages interactive quest dialogues and player progression in the game. It ensures a smooth and engaging gameplay experience by controlling when the player can interact, displaying text with a typewriter effect, and tracking quest completion.<br>
<strong style="font-weight: bold;">Key Features</strong><br> <br>
Interactive Quest UI  The UI toggles when the player is in range and presses E, disabling player movement to focus attention on the quest dialogue.
<br> <br>
Dynamic Text Display Quest texts appear character by character using a coroutine (TypeText), enhanced with typing sounds for immersion.
<br> <br>
Quest Progression  Tracks multiple quests with currentQuestIndex and questCompleted arrays, ensuring proper sequence and preventing repeated completion.
<br> <br>
Player Trigger Detection  Uses OnTriggerEnter2D and OnTriggerExit2D to detect when the player approaches or leaves the quest area, automatically enabling or disabling interaction prompts.
<br> <br>
<strong style="font-weight: bold;">Why this structure</strong><br> <br>
Separating UI toggle, text typing, and quest completion improves readability and maintainability
<br> <br>
Using coroutines for typewriting ensures smooth text animation without blocking the main game loop
<br> <br>
Player movement is properly locked during dialogue to prevent accidental interruptions.
<br> <br>
</h2>
      <img src="picture/p10.png" alt="" class="coding">
      <img src="picture/p11.png" alt="" class="coding">


          <!-- Random Key System-->
      <h2 style="text-align: left;">RandomKey <br>

RandomKey handles randomly assigning positions and sprites (keys) for quest objects, ensuring variety while preventing duplicates. It tracks which positions have already been used and maintains consistency for unfinished quests.<br>
<strong style="font-weight: bold;">Key Features</strong><br> <br>

<strong style="font-weight: bold;">Stores positions & sprites</strong><br>
password[] is randomly initialized in Start() to give each key a unique appearance
<br> <br>

<strong style="font-weight: bold;">Initial random setup</strong><br>
positions: possible key locations <br>
keys: key sprites
<br> <br>
<strong style="font-weight: bold;">Random assignment (randomKey)</strong><br>
Returns an available position index and updates the child’s position and sprite for quest i <br>

If the quest is ongoing and matches the last one, it reuses the previous position to keep consistency <br>

Ensures new positions are not reused via usedPositionIndices
<br> <br>
<strong style="font-weight: bold;">Avoids duplication</strong><br>
Prevents overlapping positions until all have been used <br>

Logs a warning if no positions are lef
<br> <br>
<strong style="font-weight: bold;">Sprite & collider adjustment</strong><br>
Automatically updates the sprite and collider size to match the assigned key
<br> <br>

<strong style="font-weight: bold;">Why this structure</strong><br> <br>
Maintains position consistency for unfinished quests
<br> <br>
Prevents duplicate positions for different keys
<br> <br>
Keeps code modular and easy to maintain
<br> <br>
Provides developer feedback when positions run out
</h2>
      <img src="picture/p12.png" alt="" class="coding">
      
    </div>

</div>


</div>


</body>
</html>